# coding: utf-8

"""
    Torn API

      * The development of Torn's API v2 is still ongoing.  * If selections remain unaltered, they will default to the API v1 version.  * Unlike API v1, API v2 accepts both selections and IDs as path and query parameters.  * If any discrepancies or errors are found, please submit a [bug report](https://www.torn.com/forums.php#/p=forums&f=19&b=0&a=0) on the Torn Forums.  * In case you're using bots to check for changes on openapi.json file, make sure to specificy a custom user-agent header - CloudFlare sometimes prevents requests from default user-agents.

    The version of the OpenAPI document: 1.5.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from tornclient.models.attack_modifiers import AttackModifiers
from tornclient.models.attack_player import AttackPlayer
from tornclient.models.attacking_finishing_hit_effects import AttackingFinishingHitEffects
from tornclient.models.faction_attack_result import FactionAttackResult
from typing import Optional, Set
from typing_extensions import Self

class Attack(BaseModel):
    """
    Attack
    """ # noqa: E501
    id: StrictInt
    code: StrictStr
    started: StrictInt = Field(description="Attack start timestamp.")
    ended: StrictInt = Field(description="Attack end timestamp.")
    attacker: Optional[AttackPlayer]
    defender: AttackPlayer
    result: FactionAttackResult
    respect_gain: Union[StrictFloat, StrictInt]
    respect_loss: Union[StrictFloat, StrictInt]
    chain: StrictInt
    is_interrupted: StrictBool = Field(description="This is an experimental flag which should help determine 'assist' attacks which have not contributed to the chain. For example, attacks such as where the opponent lost to someoene else before the attacker could finish the attack. This flag might not work entirely correctly, so use with caution.")
    is_stealthed: StrictBool
    is_raid: StrictBool
    is_ranked_war: StrictBool
    finishing_hit_effects: List[AttackingFinishingHitEffects]
    modifiers: AttackModifiers
    __properties: ClassVar[List[str]] = ["id", "code", "started", "ended", "attacker", "defender", "result", "respect_gain", "respect_loss", "chain", "is_interrupted", "is_stealthed", "is_raid", "is_ranked_war", "finishing_hit_effects", "modifiers"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Attack from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of attacker
        if self.attacker:
            _dict['attacker'] = self.attacker.to_dict()
        # override the default output from pydantic by calling `to_dict()` of defender
        if self.defender:
            _dict['defender'] = self.defender.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in finishing_hit_effects (list)
        _items = []
        if self.finishing_hit_effects:
            for _item_finishing_hit_effects in self.finishing_hit_effects:
                if _item_finishing_hit_effects:
                    _items.append(_item_finishing_hit_effects.to_dict())
            _dict['finishing_hit_effects'] = _items
        # override the default output from pydantic by calling `to_dict()` of modifiers
        if self.modifiers:
            _dict['modifiers'] = self.modifiers.to_dict()
        # set to None if attacker (nullable) is None
        # and model_fields_set contains the field
        if self.attacker is None and "attacker" in self.model_fields_set:
            _dict['attacker'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Attack from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "code": obj.get("code"),
            "started": obj.get("started"),
            "ended": obj.get("ended"),
            "attacker": AttackPlayer.from_dict(obj["attacker"]) if obj.get("attacker") is not None else None,
            "defender": AttackPlayer.from_dict(obj["defender"]) if obj.get("defender") is not None else None,
            "result": obj.get("result"),
            "respect_gain": obj.get("respect_gain"),
            "respect_loss": obj.get("respect_loss"),
            "chain": obj.get("chain"),
            "is_interrupted": obj.get("is_interrupted"),
            "is_stealthed": obj.get("is_stealthed"),
            "is_raid": obj.get("is_raid"),
            "is_ranked_war": obj.get("is_ranked_war"),
            "finishing_hit_effects": [AttackingFinishingHitEffects.from_dict(_item) for _item in obj["finishing_hit_effects"]] if obj.get("finishing_hit_effects") is not None else None,
            "modifiers": AttackModifiers.from_dict(obj["modifiers"]) if obj.get("modifiers") is not None else None
        })
        return _obj


